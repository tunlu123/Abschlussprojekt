pipeline {
  agent any

  parameters {
    choice(
      name: 'BUILD_ENV',
      choices: ['dev', 'prod'],
      description: 'Wählen Sie die Zielumgebung (dev oder prod)'
    )
  }

  environment {
    IMAGE_BACKEND = "my-backend-image"
    IMAGE_FRONTEND = "my-frontend-image"
    REGISTRY_URL = "registrykurs1.azurecr.io"
  }

  stages {

    stage('Build Backend') {
      steps {
        dir('backend') {
          sh "mvn clean package -P${params.BUILD_ENV}"
        }
      }
    }

    stage('Test Backend') {
      steps {
        dir('backend') {
          sh "mvn test"
        }
      }
    }

    stage('Build Frontend') {
      steps {
        dir('frontend') {
          sh "npm install && npm run build"
        }
      }
    }

    stage('Test Frontend') {
      steps {
        dir('frontend') {
          sh "npm test || true"
        }
      }
    }

    stage('Docker Build') {
      steps {
        sh """
          docker build -t ${REGISTRY_URL}/${IMAGE_BACKEND}:${params.BUILD_ENV} ./backend
          docker build -t ${REGISTRY_URL}/${IMAGE_FRONTEND}:${params.BUILD_ENV} ./frontend
        """
      }
    }

    stage('Docker Push') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: 'azure-credentials',
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh """
            echo "$DOCKER_PASS" | docker login $REGISTRY_URL -u "$DOCKER_USER" --password-stdin
            docker push ${REGISTRY_URL}/${IMAGE_BACKEND}:${params.BUILD_ENV}
            docker push ${REGISTRY_URL}/${IMAGE_FRONTEND}:${params.BUILD_ENV}
          """
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        script {
          def kubeconfigId = params.BUILD_ENV == 'dev' ? 'kubeconfig-dev' : 'kubeconfig-prod'
          def namespace = params.BUILD_ENV == 'dev' ? 'talha-dev' : 'talha-prod'
          def manifestPath = "k8s/${params.BUILD_ENV}"

          withCredentials([file(credentialsId: kubeconfigId, variable: 'KUBECONFIG')]) {
            sh """
              export KUBECONFIG="$KUBECONFIG"
              kubectl apply -f ${manifestPath} --namespace=${namespace}
              kubectl rollout status deployment/backend -n ${namespace} --timeout=300s
              kubectl rollout status deployment/frontend -n ${namespace} --timeout=300s
            """
          }
        }
      }
    }
  }

  post {
    always {
      cleanWs()
      echo "Pipeline abgeschlossen für Umgebung: ${params.BUILD_ENV}"
    }

    success {
      slackSend(
        color: 'good',
        message: "✅ Erfolgreich deployed: Build #${env.BUILD_NUMBER} → `${params.BUILD_ENV}`"
      )
    }

    failure {
      slackSend(
        color: 'danger',
        message: "❌ Fehler beim Deployment: Build #${env.BUILD_NUMBER} → `${params.BUILD_ENV}`"
      )
    }
  }
}
