pipeline {
  agent any

  parameters {
    choice(
      name: 'BUILD_ENV',
      choices: ['dev', 'prod'],
      description: 'W√§hlen Sie die Zielumgebung (dev oder prod)'
    )
  }

  environment {
    IMAGE_BACKEND = "backend-app"
    IMAGE_FRONTEND = "frontend-app"
    REGISTRY_URL = "registrykurs1.azurecr.io"
    DEPLOYMENT_TIMEOUT = "600"  // 10 Minuten Timeout
    KUBE_DEBUG = "true"         // Debugging aktivieren
  }

  stages {
    stage('Build Backend') {
      steps {
        dir('backend') {
          sh "mvn clean package -P${params.BUILD_ENV}"
        }
      }
    }

    stage('Test Backend') {
      steps {
        dir('backend') {
          sh "mvn test"
        }
      }
    }

    stage('Build Frontend') {
      steps {
        dir('frontend') {
          sh "npm install && npm run build"
        }
      }
    }

    stage('Test Frontend') {
      steps {
        dir('frontend') {
          sh "npm test || true"  // Fortsetzen auch bei Testfehlern
        }
      }
    }

    stage('Docker Build') {
      steps {
        sh """
          docker build -t ${REGISTRY_URL}/${IMAGE_BACKEND}:${params.BUILD_ENV} ./backend
          docker build -t ${REGISTRY_URL}/${IMAGE_FRONTEND}:${params.BUILD_ENV} ./frontend
        """
      }
    }

    stage('Docker Push') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: 'azure-credentials',
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh """
            echo "\$DOCKER_PASS" | docker login $REGISTRY_URL -u "\$DOCKER_USER" --password-stdin
            docker push ${REGISTRY_URL}/${IMAGE_BACKEND}:${params.BUILD_ENV}
            docker push ${REGISTRY_URL}/${IMAGE_FRONTEND}:${params.BUILD_ENV}
          """
        }
      }
    }

    stage('Prepare Deployment') {
      steps {
        script {
          // Environment-spezifische Variablen setzen
          env.KUBECONFIG_ID = params.BUILD_ENV == 'dev' ? 'kubeconfig-talha-dev' : 'kubeconfig-talha-prod'
          env.NAMESPACE = params.BUILD_ENV == 'dev' ? 'talha-dev' : 'talha-prod'
          env.MANIFEST_PATH = "k8s/${params.BUILD_ENV}"
        }
      }
    }

    stage('Clean Old Deployments') {
      steps {
        withCredentials([file(credentialsId: env.KUBECONFIG_ID, variable: 'KUBECONFIG')]) {
          sh """
            export KUBECONFIG="\$KUBECONFIG"
            echo "üóëÔ∏è L√∂sche alte Deployments..."
            kubectl delete deployment backend -n ${env.NAMESPACE} || true
            kubectl delete deployment frontend -n ${env.NAMESPACE} || true
            kubectl delete service backend-service -n ${env.NAMESPACE} || true
            kubectl delete service frontend-service -n ${env.NAMESPACE} || true
            echo "‚úÖ Alte Ressourcen bereinigt"
          """
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        withCredentials([file(credentialsId: env.KUBECONFIG_ID, variable: 'KUBECONFIG')]) {
          sh """
            export KUBECONFIG="$KUBECONFIG"
            echo "üöÄ Starte Deployment..."
            
            # Anwenden der Kubernetes-Manifeste
            kubectl apply -f ${env.MANIFEST_PATH} --namespace=${env.NAMESPACE}
            
            
            # Debug-Informationen
            if [ "\$KUBE_DEBUG" = "true" ]; then
              echo "üîç Debug-Informationen:"
              kubectl get pods -n ${env.NAMESPACE}
              kubectl describe deployments -n ${env.NAMESPACE}
              kubectl get events -n ${env.NAMESPACE} --sort-by=.metadata.creationTimestamp
            fi
            
            echo "‚úÖ Deployment erfolgreich abgeschlossen"
          """
        }
      }
    }
  }

  post {
    always {
      cleanWs()
      echo "Pipeline abgeschlossen f√ºr Umgebung: ${params.BUILD_ENV}"
    }

    success {
      echo "‚úÖ Erfolgreich deployed: Build #${env.BUILD_NUMBER} ‚Üí `${params.BUILD_ENV}`"
    }

    failure {
      echo "‚ùå Fehler beim Deployment: Build #${env.BUILD_NUMBER} ‚Üí `${params.BUILD_ENV}`"
      
    
      // Fehlerdiagnose bei Failure
      script {
        withCredentials([file(credentialsId: env.KUBECONFIG_ID, variable: 'KUBECONFIG')]) {
          sh """
            export KUBECONFIG="\$KUBECONFIG"
            echo "‚ùå Fehlerdiagnose:"
            kubectl get pods -n ${env.NAMESPACE}
            kubectl describe pods -n ${env.NAMESPACE} | grep -A 20 "backend"
            kubectl logs deployment/backend -n ${env.NAMESPACE} --tail=50 || true
          """
        }
      }
    }
  }
}