pipeline {
  agent any
 
  parameters {
    choice(
      name: 'BUILD_ENV',
      choices: ['dev', 'prod'],
      description: 'Wählen Sie die Zielumgebung'
    )
  }
 
  environment {
    IMAGE_BACKEND = "backend-app"
    IMAGE_FRONTEND = "frontend-app"
    REGISTRY_URL = "registrykurs1.azurecr.io"
  }
 
  stages {
    stage('Build Backend') {
      steps {
        dir('backend') {
          sh "mvn clean package -P${params.BUILD_ENV}"
        }
      }
    }

    stage('Test Backend') {
      steps {
        dir('backend') {
          sh "mvn test"
        }
      }
    }

    stage('Build Frontend') {
      steps {
        dir('frontend') {
          sh "npm install && npm run build"
        }
      }
    }

    stage('Test Frontend') {
      steps {
        dir('frontend') {
          sh "npm test || true"
        }
      }
    }

    stage('Docker Build') {
      steps {
        sh "docker build -t ${REGISTRY_URL}/${IMAGE_BACKEND}:${params.BUILD_ENV} ./backend"
        sh "docker build -t ${REGISTRY_URL}/${IMAGE_FRONTEND}:${params.BUILD_ENV} ./frontend"
      }
    }

stage('Docker Push') {
  steps {
    script {
      // Deine Registry-URL
      def REPOSITORY = "registrykurs1.azurecr.io"
      
      // Die ID deiner Jenkins Credentials für Azure (muss "azure-credentials" sein)
      // Diese Credentials müssen als "Username with password" hinterlegt sein.
      withCredentials([usernamePassword(credentialsId: 'azure-credentials', usernameVariable: 'ACR_USERNAME', passwordVariable: 'ACR_PASSWORD')]) {
        // Docker Login bei deiner Azure Container Registry
        sh "docker login ${REPOSITORY} -u ${ACR_USERNAME} -p ${ACR_PASSWORD}"

        // Backend-Image pushen (Beispiel)
        // Ersetze 'your-backend-image-name' durch den tatsächlichen Namen deines Backend-Images
        // 'env.BUILD_NUMBER' ist eine Standard-Jenkins-Variable für die Build-Nummer
        sh "docker push ${REPOSITORY}/your-backend-image-name:${env.BUILD_NUMBER}"

        // Frontend-Image pushen (Beispiel)
        // Ersetze 'your-frontend-image-name' durch den tatsächlichen Namen deines Frontend-Images
        sh "docker push ${REPOSITORY}/your-frontend-image-name:${env.BUILD_NUMBER}"

        // Optional: Logout nach dem Push
        sh "docker logout ${REPOSITORY}"
      }
    }
  }
}

    stage('Deploy') {
      steps {
        script {
          def kubeconfig = params.BUILD_ENV == 'dev' ? 'kubeconfig-talha-dev' : 'kubeconfig-talha-prod'
          def namespace = params.BUILD_ENV
          def manifest = "k8s/${params.BUILD_ENV}"
          
          withCredentials([file(credentialsId: kubeconfig, variable: 'KUBECONFIG')]) {
            sh """
              kubectl apply -f ${manifest} --namespace=${namespace}
              kubectl rollout status deployment/backend -n ${namespace} --timeout=300s
              kubectl rollout status deployment/frontend -n ${namespace} --timeout=300s
            """
          }
        }
      }
    }
  } 
  
  post {
    always {
      cleanWs()
      echo "Pipeline abgeschlossen für ${params.BUILD_ENV}"
    }
    success {
      slackSend(
        color: 'good',
        message: "Erfolgreich deployed: Build #${env.BUILD_NUMBER} -> ${params.BUILD_ENV}"
      )
    }
    failure {
      slackSend(
        color: 'danger',
        message: "Fehler beim Deployment: Build #${env.BUILD_NUMBER} -> ${params.BUILD_ENV}"
      )
    }
  }
}